.TH "com.thealgorithms.divideandconquer.SkylineAlgorithm" 3 "Fri Jan 28 2022" "Examen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
com.thealgorithms.divideandconquer.SkylineAlgorithm
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBPoint\fP"
.br
.ti -1c
.RI "class \fBXComparator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSkylineAlgorithm\fP ()"
.br
.ti -1c
.RI "ArrayList< Point > \fBgetPoints\fP ()"
.br
.ti -1c
.RI "ArrayList< Point > \fBproduceSubSkyLines\fP (ArrayList< Point > list)"
.br
.ti -1c
.RI "ArrayList< Point > \fBproduceFinalSkyLine\fP (ArrayList< Point > left, ArrayList< Point > right)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBAuthor\fP
.RS 4
dimgrichr 
.RE
.PP
Space complexity: O(n) Time complexity: O(nlogn), because it is a divide and conquer algorithm 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "com\&.thealgorithms\&.divideandconquer\&.SkylineAlgorithm\&.SkylineAlgorithm ()"
Main constructor of the application\&. ArrayList points gets created, which represents the sum of all edges\&. 
.SH "Member Function Documentation"
.PP 
.SS "ArrayList< Point > com\&.thealgorithms\&.divideandconquer\&.SkylineAlgorithm\&.getPoints ()"

.PP
\fBReturns\fP
.RS 4
points, the ArrayList that includes all points\&. 
.RE
.PP

.SS "ArrayList< Point > com\&.thealgorithms\&.divideandconquer\&.SkylineAlgorithm\&.produceFinalSkyLine (ArrayList< Point > left, ArrayList< Point > right)"
The first half's skyline gets cleared from some points that are not part of the final skyline (Points with same x-value and different y=values\&. The point with the smallest y-value is kept)\&. Then, the minimum y-value of the points of first half's skyline is found\&. That helps us to clear the second half's skyline, because, the points of second half's skyline that have greater y-value of the minimum y-value that we found before, are dominated, so they are not part of the final skyline\&. Finally, the 'cleaned' first half's and second half's skylines, are combined, producing the final skyline, which is returned\&.
.PP
\fBParameters\fP
.RS 4
\fIleft\fP the skyline of the left part of points 
.br
\fIright\fP the skyline of the right part of points 
.RE
.PP
\fBReturns\fP
.RS 4
left the final skyline 
.RE
.PP

.SS "ArrayList< Point > com\&.thealgorithms\&.divideandconquer\&.SkylineAlgorithm\&.produceSubSkyLines (ArrayList< Point > list)"
The main divide and conquer, and also recursive algorithm\&. It gets an ArrayList full of points as an argument\&. If the size of that ArrayList is 1 or 2, the ArrayList is returned as it is, or with one less point (if the initial size is 2 and one of it's points, is dominated by the other one)\&. On the other hand, if the ArrayList's size is bigger than 2, the function is called again, twice, with arguments the corresponding half of the initial ArrayList each time\&. Once the flashback has ended, the function produceFinalSkyLine gets called, in order to produce the final skyline, and return it\&.
.PP
\fBParameters\fP
.RS 4
\fIlist,the\fP initial list of points 
.RE
.PP
\fBReturns\fP
.RS 4
leftSkyLine, the combination of first half's and second half's skyline 
.RE
.PP
\fBSee also\fP
.RS 4
Point 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Examen from the source code\&.
