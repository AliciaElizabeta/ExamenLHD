.TH "md_src_main_java_com_thealgorithms_datastructures_heaps__readme" 3 "Fri Jan 28 2022" "Examen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_src_main_java_com_thealgorithms_datastructures_heaps__readme \- Readme 
\fB
.SH "HEAP DATA STRUCTURE"
.PP
\fP
.PP
\fB\fP 
.PP
A Heap is a special Tree-based data structure in which the tree is a complete binary tree\&.
.SS "<h2>Complete Binary Tree</h2>"
A complete binary tree is a binary tree in which all the levels except the last level, i\&.e\&., leaf node should be completely filled, and all the nodes should be left-justified\&.
.PP
.PP
.nf
        10
      /    \
    20      30
   /  \    
  40   50
  
COMPLETE BINARY TREE
.fi
.PP
.SS "<h2>Types of Heap</h2>"
Generally, Heaps can be of two types: 
.br
 \fBMax-Heap:\fP In a Max-Heap the key present at the root node must be greatest among the keys present at all of it’s children\&. The same property must be recursively true for all sub-trees in that Binary Tree\&. 
.br
 \fBMin-Heap:\fP In a Min-Heap the key present at the root node must be minimum among the keys present at all of it’s children\&. The same property must be recursively true for all sub-trees in that Binary Tree\&. 
.PP
.PP
.nf
      10
    /    \
  20      30
 /  \    /  \
40  50  60  70

    MIN HEAP
.fi
.PP
.PP
.PP
.nf
      70
    /    \
  50      60
 /  \    /  \
40  30  10   20

    MAX HEAP
.fi
.PP
.SS "<h2>Min Heap Construction Algorithm</h2>"
.PP
.nf
Step 1 − Create a new node at the end of heap\&.
Step 2 − Assign new value to the node\&.
Step 3 − Compare the value of this child node with its parent\&.
Step 4 − If value of parent is more than child, then swap them\&.
Step 5 − Repeat step 3 & 4 until Heap property holds\&.
.fi
.PP
.PP
.PP
.nf
Add 15

                            10                         10                     10
                          /    \                     /   \                  /    \
                        20      30    ------>      20     30   ------>     20     15
                       /  \                       /  \   /                /  \    /  
                      40  50                    40   50  15              40  50  30
.fi
.PP
.SS "<h2>Min Heap Deletion Algorithm</h2>"
.PP
.nf
Step 1 − Remove root node\&.
Step 2 − Move the last element of last level to root\&.
Step 3 − Compare the value of this child node with its parent\&.
Step 4 − If value of parent is more than child, then swap them\&.
Step 5 − Repeat step 3 & 4 until Heap property holds\&.
.fi
.PP
.PP
.PP
.nf
Delete 10

                            10                        50                     20                   20
                          /    \                     /   \                  /   \                /  \
                        20      30    ------>      20     30   ------>     50    30   ------>   40   30
                       /  \                       /                       /                    /
                      40  50                    40                       40                   50
.fi
.PP
.SS "<h2>Time Complexity (Min Heap)</h2>"
Operations Sorted Array UnSorted Array Heap  Add O(N) O(1) O(logN)  
.br
 Delete Minimum O(N) O(N) O(logN)  Get Minimum O(1) O(N) O(1)  
.SS "<h2>Applications of Heap Data Structure</h2>"
\fBHeapsort:\fP Heapsort algorithm has limited uses because Quicksort is better in practice\&. Nevertheless, the Heap data structure itself is enormously used\&.
.PP
\fBPriority Queues:\fP Priority queues can be efficiently implemented using Binary Heap because it supports insert(), delete() and extractmax(), decreaseKey() operations in O(logn) time\&. Binomoial Heap and Fibonacci Heap are variations of Binary Heap\&. These variations perform union also in O(logn) time which is a O(n) operation in Binary Heap\&. Heap Implemented priority queues are used in Graph algorithms like Prim’s Algorithm and Dijkstra’s algorithm\&.
.PP
\fBOrder statistics:\fP The Heap data structure can be used to efficiently find the kth smallest (or largest) element in an array\&. 
