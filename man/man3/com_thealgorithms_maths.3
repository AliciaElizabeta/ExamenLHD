.TH "com.thealgorithms.maths" 3 "Fri Jan 28 2022" "Examen" \" -*- nroff -*-
.ad l
.nh
.SH NAME
com.thealgorithms.maths
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBAbsoluteMax\fP"
.br
.ti -1c
.RI "class \fBAbsoluteMin\fP"
.br
.ti -1c
.RI "class \fBAbsoluteValue\fP"
.br
.ti -1c
.RI "class \fBADTFraction\fP"
.br
.ti -1c
.RI "class \fBAliquotSum\fP"
.br
.ti -1c
.RI "class \fBAmicableNumber\fP"
.br
.ti -1c
.RI "class \fBArea\fP"
.br
.ti -1c
.RI "class \fBArmstrong\fP"
.br
.ti -1c
.RI "class \fBAutomorphicNumber\fP"
.br
.ti -1c
.RI "class \fBAverage\fP"
.br
.ti -1c
.RI "class \fBBinaryPow\fP"
.br
.ti -1c
.RI "class \fBBinomialCoefficient\fP"
.br
.ti -1c
.RI "class \fBCeil\fP"
.br
.ti -1c
.RI "class \fBCircularConvolutionFFT\fP"
.br
.ti -1c
.RI "class \fBCombinations\fP"
.br
.ti -1c
.RI "class \fBConvolution\fP"
.br
.ti -1c
.RI "class \fBConvolutionFFT\fP"
.br
.ti -1c
.RI "class \fBDeterminantOfMatrix\fP"
.br
.ti -1c
.RI "class \fBDigitalRoot\fP"
.br
.ti -1c
.RI "class \fBDudeneyNumber\fP"
.br
.ti -1c
.RI "class \fBEulerMethod\fP"
.br
.ti -1c
.RI "class \fBFactorial\fP"
.br
.ti -1c
.RI "class \fBFactorialRecursion\fP"
.br
.ti -1c
.RI "class \fBFFT\fP"
.br
.ti -1c
.RI "class \fBFFTBluestein\fP"
.br
.ti -1c
.RI "class \fBFibonacciJavaStreams\fP"
.br
.ti -1c
.RI "class \fBFibonacciNumber\fP"
.br
.ti -1c
.RI "class \fBFindMax\fP"
.br
.ti -1c
.RI "class \fBFindMaxRecursion\fP"
.br
.ti -1c
.RI "class \fBFindMin\fP"
.br
.ti -1c
.RI "class \fBFindMinRecursion\fP"
.br
.ti -1c
.RI "class \fBFloor\fP"
.br
.ti -1c
.RI "class \fBGaussian\fP"
.br
.ti -1c
.RI "class \fBGCD\fP"
.br
.ti -1c
.RI "class \fBGCDRecursion\fP"
.br
.ti -1c
.RI "class \fBGenericRoot\fP"
.br
.ti -1c
.RI "class \fBHarshadNumber\fP"
.br
.ti -1c
.RI "class \fBJugglerSequence\fP"
.br
.ti -1c
.RI "class \fBKaprekarNumbers\fP"
.br
.ti -1c
.RI "class \fBKeithNumber\fP"
.br
.ti -1c
.RI "class \fBKrishnamurthyNumber\fP"
.br
.ti -1c
.RI "class \fBLeonardoNumber\fP"
.br
.ti -1c
.RI "class \fBLucasSeries\fP"
.br
.ti -1c
.RI "class \fBMagicSquare\fP"
.br
.ti -1c
.RI "class \fBMatrixUtil\fP"
.br
.ti -1c
.RI "class \fBMaxValue\fP"
.br
.ti -1c
.RI "class \fBMedian\fP"
.br
.ti -1c
.RI "class \fBMinValue\fP"
.br
.ti -1c
.RI "class \fBMode\fP"
.br
.ti -1c
.RI "class \fBNonRepeatingElement\fP"
.br
.ti -1c
.RI "class \fBNthUglyNumber\fP"
.br
.ti -1c
.RI "class \fBNumberOfDigits\fP"
.br
.ti -1c
.RI "class \fBPalindromeNumber\fP"
.br
.ti -1c
.RI "class \fBParseInteger\fP"
.br
.ti -1c
.RI "class \fBPascalTriangle\fP"
.br
.ti -1c
.RI "class \fBPerfectCube\fP"
.br
.ti -1c
.RI "class \fBPerfectNumber\fP"
.br
.ti -1c
.RI "class \fBPerfectSquare\fP"
.br
.ti -1c
.RI "class \fBPiNilakantha\fP"
.br
.ti -1c
.RI "class \fBPow\fP"
.br
.ti -1c
.RI "class \fBPowerOfTwoOrNot\fP"
.br
.ti -1c
.RI "class \fBPowRecursion\fP"
.br
.ti -1c
.RI "class \fBPrimeCheck\fP"
.br
.ti -1c
.RI "class \fBPrimeFactorization\fP"
.br
.ti -1c
.RI "class \fBPronicNumber\fP"
.br
.ti -1c
.RI "class \fBPythagoreanTriple\fP"
.br
.ti -1c
.RI "class \fBReverseNumber\fP"
.br
.ti -1c
.RI "class \fBRomanNumeralUtil\fP"
.br
.ti -1c
.RI "class \fBSimpsonIntegration\fP"
.br
.ti -1c
.RI "class \fBSumOfArithmeticSeries\fP"
.br
.ti -1c
.RI "class \fBSumOfDigits\fP"
.br
.ti -1c
.RI "class \fBTrinomialTriangle\fP"
.br
.ti -1c
.RI "class \fBVampireNumber\fP"
.br
.ti -1c
.RI "class \fBVolume\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Author : Suraj Kumar Modi https://github.com/skmodi649 You are given a number n\&. You need to find the digital root of n\&. DigitalRoot of a number is the recursive sum of its digits until we get a single digit number\&.
.PP
Test Case 1: Input: n = 1 Output: 1 Explanation: Digital root of 1 is 1
.PP
Test Case 2: Input: n = 99999 Output: 9 Explanation: Sum of digits of 99999 is 45 which is not a single digit number, hence sum of digit of 45 is 9 which is a single digit number\&. Algorithm : Step 1 : Define a method digitalRoot(int n) Step 2 : Define another method single(int n) Step 3 : digitalRoot(int n) method takes output of single(int n) as input if(single(int n) <= 9) return single(n) else return digitalRoot(single(n)) Step 4 : single(int n) calculates the sum of digits of number n recursively if(n<=9) return n; else return (n%10) + (n/10) Step 5 : In main method simply take n as input and then call digitalRoot(int n) function and print the result
.PP
A number is said to be Dudeney if the sum of the digits, is the cube root of the entered number\&. Example- Let the number be 512, its sum of digits is 5+1+2=8\&. The cube root of 512 is also 8\&. Since, the sum of the digits is equal to the cube root of the entered number; it is a Dudeney Number\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Examen from the source code\&.
