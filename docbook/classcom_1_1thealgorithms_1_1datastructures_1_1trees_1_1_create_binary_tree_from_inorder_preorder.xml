<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_classcom_1_1thealgorithms_1_1datastructures_1_1trees_1_1_create_binary_tree_from_inorder_preorder" xml:lang="en-US">
<title>com.thealgorithms.datastructures.trees.CreateBinaryTreeFromInorderPreorder Class Reference</title>
<indexterm><primary>com.thealgorithms.datastructures.trees.CreateBinaryTreeFromInorderPreorder</primary></indexterm>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_classcom_1_1thealgorithms_1_1datastructures_1_1trees_1_1_create_binary_tree_from_inorder_preorder_1a68aadbe2b6fb1b8a0cd171760aae566e"/>static void <emphasis role="strong">main</emphasis> (String[] args)</para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>Approach: Naive Solution: Create root node from first value present in preorder traversal. Look for the index of root node&apos;s value in inorder traversal. That will tell total nodes present in left subtree and right subtree. Based on that index create left and right subtree. Complexity: Time: O(n^2) for each node there is iteration to find index in inorder array Space: Stack size = O(height) = O(lg(n))</para>

<para>Optimized Solution: Instead of iterating over inorder array to find index of root value, create a hashmap and find out the index of root value. Complexity: Time: O(n) hashmap reduced iteration to find index in inorder array Space: O(n) space taken by hashmap </para>
<para>
The documentation for this class was generated from the following file:</para>
src/main/java/com/thealgorithms/datastructures/trees/CreateBinaryTreeFromInorderPreorder.java</section>
</section>
